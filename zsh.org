#+title: ZSH Configuration
* zenv
:PROPERTIES:
:header-args: :tangle ~/.zshenv :mkdirp yes
:END:

Prepend path to emacs to path

#+BEGIN_SRC sh
  export XDG_CONFIG_HOME="$HOME/.config"
  export XDG_DATA_HOME="$XDG_CONFIG_HOME/local/share"
  export XDG_CACHE_HOME="$XDG_CONFIG_HOME/cache"

  export EDITOR="emacsclient"
  export VISUAL="emacsclient"

  export ZDOTDIR="$XDG_CONFIG_HOME/zsh" # Zsh folder
  export HISTFILE="$ZDOTDIR/.zhistory" # History filepath
  export HISTSIZE=10000 # Maximum events for internal history
  export SAVEHIST=10000 # Maximum events in history file

  # gpg
  GPG_TTY=$(tty)
  export GPG_TTY

  # Encodings
  export LANG=en_US.UTF-8

  # add .local/bin to path
  PATH=$HOME/.local/bin:$PATH

  # add local applications to path
  PATH=$HOME/.local/share/applications:$PATH

  # prepend emacs to path
  PATH=$HOME/git/emacs/src:$PATH

  # Increase emacs lsp performance
  export LSP_USE_PLISTS=true

  # add kotlin language server to path
  PATH=$HOME/git/kotlin-language-server/server/build/install/server/bin:$PATH
  # add kotlin debug adapter to path
  PATH=$HOME/git/kotlin-debug-adapter/adapter/build/install/adapter/bin:$PATH

  # Add cargo to path
  PATH=$HOME/.cargo/env:$PATH

  # set WORKON dir
  WORKON_HOME=$HOME/.pyenv/versions
#+END_SRC 

* zprofile
:PROPERTIES:
:header-args: :tangle ~/.config/zsh/.zprofile :mkdirp yes
:END:

#+BEGIN_SRC sh
#+END_SRC

* zshrc
:PROPERTIES:
:header-args: :tangle ~/.config/zsh/.zshrc :mkdirp yes
:END:

Define some color variables

#+begin_src shell

    BLACK='\033[0;30m'
    DARKGRAY='\033[1;30m'
    RED='\033[0;31m'
    LIGHTRED='\033[1;31m'
    GREEN='\033[0;32m'
    LIGHTGREEN='\033[1;32m'
    BROWN='\033[0;33m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    LIGHTBLUE='\033[1;34m'
    PURPLE='\033[0;35m'
    LIGHTPURPLE='\033[1;35m'
    CYAN='\033[0;36m'
    LIGHTCYAN='\033[1;36m'
    LIGHTGRAY='\033[0;37m'
    WHITE='\033[1;37m'
    NOCOLOR='\033[0;0m'


    vterm_printf(){
      if [ -n "$TMUX" ] && ([ "${TERM%%-*}" = "tmux" ] || [ "${TERM%%-*}" = "screen" ] ); then
          # Tell tmux to pass the escape sequences through
          printf "\ePtmux;\e\e]%s\007\e\\" "$1"
      elif [ "${TERM%%-*}" = "screen" ]; then
          # GNU screen (screen, screen-256color, screen-256color-bce)
          printf "\eP\e]%s\007\e\\" "$1"
      else
          printf "\e]%s\e\\" "$1"
      fi
    }
#+end_src

Set up autocomplete and suggestions

#+BEGIN_SRC shell

  # Initialize autocomplete
  autoload -U compinit; compinit

  _comp_options+=(globdots) # With hidden files

  fpath=($ZDOTDIR $fpath)
  autoload -Uz prompt.zsh; prompt.zsh

  if [[ ! -d $ZDOTDIR/plugins/zsh-autosuggestions ]]                                               
      then
          echo "${RED}zsh-autosuggestions not found, cloning${NOCOLOR}"
          git clone "http://github.com/zsh-users/zsh-autosuggestions" $ZDOTDIR/plugins/zsh-autosuggestions
          echo "${GREEN}zsh-autosuggestions successfully cloned${NOCOLOR}"
  fi

  source $ZDOTDIR/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh


 #+end_src

#+begin_src shell :tangle (if (eq system-type 'darwin) "~/.config/zsh/.zshrc" "no")
  eval "$(/opt/homebrew/bin/brew shellenv)"
#+end_src
 
* zlogin
:PROPERTIES:
:header-args: :tangle ~/.config/zsh/.zlogin :mkdirp yes
:END:

#+BEGIN_SRC sh
#+END_SRC

* zlogout
:PROPERTIES:
:header-args: :tangle ~/.config/zsh/.zlogout :mkdirp yes
:END:

#+BEGIN_SRC sh
#+END_SRC

* prompt
:PROPERTIES:
:header-args: :tangle ~/.config/zsh/prompt.zsh :mkdirp yes
:END:

#+begin_src shell
  # prompt:
  # %F => color dict
  # %f => reset color
  # %~ => current path
  # %* => time
  # %n => username
  # %m => shortname host
  # %(?..) => prompt conditional - %(condition.true.false)

  # Display git status
  # TODO to refactor with switch / using someting else than grep
  # Might be faster using ripgrep too
  git_prompt_status() {
      local INDEX STATUS

      INDEX=$(command git status --porcelain -b 2> /dev/null)

      STATUS=""

      if $(echo "$INDEX" | command grep -E '^\?\? ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_UNTRACKED$STATUS"
      fi

      if $(echo "$INDEX" | grep '^A  ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS"
      elif $(echo "$INDEX" | grep '^M  ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS"
      elif $(echo "$INDEX" | grep '^MM ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_ADDED$STATUS"
      fi

      if $(echo "$INDEX" | grep '^ M ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS"
      elif $(echo "$INDEX" | grep '^AM ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS"
      elif $(echo "$INDEX" | grep '^MM ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS"
      elif $(echo "$INDEX" | grep '^ T ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_MODIFIED$STATUS"
      fi

      if $(echo "$INDEX" | grep '^R  ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_RENAMED$STATUS"
      fi

      if $(echo "$INDEX" | grep '^ D ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS"
      elif $(echo "$INDEX" | grep '^D  ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS"
      elif $(echo "$INDEX" | grep '^AD ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_DELETED$STATUS"
      fi

      if $(command git rev-parse --verify refs/stash >/dev/null 2>&1); then
          STATUS="$ZSH_THEME_GIT_PROMPT_STASHED$STATUS"
      fi

      if $(echo "$INDEX" | grep '^UU ' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_UNMERGED$STATUS"
      fi

      if $(echo "$INDEX" | grep '^## [^ ]\+ .*ahead' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_AHEAD$STATUS"
      fi

      if $(echo "$INDEX" | grep '^## [^ ]\+ .*behind' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_BEHIND$STATUS"
      fi

      if $(echo "$INDEX" | grep '^## [^ ]\+ .*diverged' &> /dev/null); then
          STATUS="$ZSH_THEME_GIT_PROMPT_DIVERGED$STATUS"
      fi

      if [[ ! -z "$STATUS" ]]; then
          echo " [ $STATUS]"
      fi
  }


  prompt_git_branch() {
      autoload -Uz vcs_info 
      precmd_vcs_info() { vcs_info }
      precmd_functions+=( precmd_vcs_info )
      setopt prompt_subst
      zstyle ':vcs_info:git:*' formats '%10b'
  }

  prompt_git_info() {
      [ ! -z "$vcs_info_msg_0_" ] && echo "$ZSH_THEME_GIT_PROMPT_PREFIX%F{white}$vcs_info_msg_0_%f$ZSH_THEME_GIT_PROMPT_SUFFIX"
  }

  prompt_purity_precmd() {
      # Pass a line before each prompt
      print -P ''
  }

  prompt_purification_setup() {
      # Display git branch

      autoload -Uz add-zsh-hook
      add-zsh-hook precmd prompt_purity_precmd

      ZSH_THEME_GIT_PROMPT_PREFIX=" %F{red}λ%f:"
      ZSH_THEME_GIT_PROMPT_DIRTY=""
      ZSH_THEME_GIT_PROMPT_CLEAN=""

      ZSH_THEME_GIT_PROMPT_ADDED="%F{green}+%f "
      ZSH_THEME_GIT_PROMPT_MODIFIED="%F{blue}mod%f "
      ZSH_THEME_GIT_PROMPT_DELETED="%F{red}x%f "
      ZSH_THEME_GIT_PROMPT_RENAMED="%F{magenta}rname%f "
      ZSH_THEME_GIT_PROMPT_UNMERGED="%F{yellow}═%f "
      ZSH_THEME_GIT_PROMPT_UNTRACKED="%F{white}untrk%f "
      ZSH_THEME_GIT_PROMPT_STASHED="%B%F{red}stsh%f%b "
      ZSH_THEME_GIT_PROMPT_BEHIND="%B%F{red}bhnd%f%b "
      ZSH_THEME_GIT_PROMPT_AHEAD="%B%F{green}ahd%f%b "

      prompt_git_branch
      RPROMPT='$(prompt_git_info) $(git_prompt_status)'
      PROMPT=$'%F{white}%~ %B%F{blue}>%f%b '
  }

  prompt_purification_setup
#+end_src


